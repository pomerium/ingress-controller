package cmd

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"os"
	"os/signal"
	"path"
	"strconv"
	"strings"
	"text/template"

	"github.com/fsnotify/fsnotify"
	"github.com/spf13/cobra"
	"golang.org/x/crypto/ssh"
	"golang.org/x/sys/unix"
)

type SyncSshdConfigOpts struct {
	HostPomeriumConfigDir string
	HostConfigFile        string
	UserCaCert            string
	SshdPidFile           string
}

var sshdConfigTemplate = `
# Automatically generated by Pomerium Ingress Controller
TrustedUserCAKeys {{ .HostPomeriumConfigDir }}/pomerium_user_ca_key.pub
`[1:]

func ensureDirectory(cmd *cobra.Command, dir string) error {
	if d, err := os.Stat(dir); err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return fmt.Errorf("directory does not exist: %s", dir)
		}
		return fmt.Errorf("failed to stat directory %s: %w", dir, err)
	} else if !d.IsDir() {
		return fmt.Errorf("%s is not a directory", dir)
	} else {
		cmd.Printf("directory exists: %s\n", dir)
		if d.Mode() != 0o700 {
			if err := os.Chmod(dir, 0o700); err != nil {
				return fmt.Errorf("error setting permissions on %s: %w", dir, err)
			}
			cmd.Printf("set permissions on directory to 0700: %s\n", dir)
		}
		if stat, ok := d.Sys().(*unix.Stat_t); ok {
			if stat.Uid != 0 || stat.Gid != 0 {
				if err := os.Chown(dir, 0, 0); err != nil {
					return fmt.Errorf("error changing ownership of %s to root: %w", dir, err)
				}
				cmd.Printf("changed ownership of directory to root: %s\n", dir)
			}
		}
	}
	return nil
}

func ensurePermissions(cmd *cobra.Command, file string) error {
	if f, err := os.Stat(file); err != nil {
		return err
	} else {
		if f.Mode() != 0o600 {
			cmd.Printf("setting permissions on file to 0600: %s\n", file)
			if err := os.Chmod(file, 0o600); err != nil {
				return fmt.Errorf("error setting permissions on %s: %w", file, err)
			}
		}
		if stat, ok := f.Sys().(*unix.Stat_t); ok {
			if stat.Uid != 0 || stat.Gid != 0 {
				cmd.Printf("changing ownership of file to root: %s\n", file)
				if err := os.Chown(file, 0, 0); err != nil {
					return fmt.Errorf("error changing ownership of %s to root: %w", file, err)
				}
			}
		}
		return nil
	}
}

func syncPublicKey(cmd *cobra.Command, dst string, src string) (bool, error) {
	if _, err := os.Stat(src); err != nil {
		return false, fmt.Errorf("file %s does not exist: %w", src, err)
	}
	srcData, err := os.ReadFile(src)
	if err != nil {
		return false, fmt.Errorf("error reading %s: %w", src, err)
	}
	// validate that the file is actually a public key
	key, _, _, _, err := ssh.ParseAuthorizedKey(srcData)
	if err != nil {
		return false, fmt.Errorf("file is not a valid ssh public key: %s: %w", src, err)
	}
	return syncFile(cmd, dst, ssh.MarshalAuthorizedKey(key))
}

func syncFile(cmd *cobra.Command, dst string, expected []byte) (bool, error) {
	needsWrite := false
	if _, err := os.Stat(dst); err == nil {
		cmd.Printf("file exists on disk: %s\n", dst)
		destData, err := os.ReadFile(dst)
		if err != nil {
			return false, fmt.Errorf("error reading %s: %w", dst, err)
		}
		if err := ensurePermissions(cmd, dst); err != nil {
			return false, err
		}
		if !bytes.Equal(expected, destData) {
			cmd.Printf("file is out of date, updating: %s\n", dst)
			needsWrite = true
		} else {
			cmd.Printf("file is up to date: %s\n", dst)
		}
	} else if errors.Is(err, os.ErrNotExist) {
		needsWrite = true
	} else {
		return false, fmt.Errorf("failed to stat file %s: %w", dst, err)
	}
	if !needsWrite {
		return false, nil
	}

	f, err := os.OpenFile(dst, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0o600)
	if err != nil {
		return false, fmt.Errorf("error opening %s: %w", dst, err)
	}
	defer f.Close()
	if err := f.Chmod(0o600); err != nil {
		return false, fmt.Errorf("error setting permissions on %s: %w", dst, err)
	}
	if err := f.Chown(0, 0); err != nil {
		return false, fmt.Errorf("error changing ownership of %s to root: %w", dst, err)
	}
	if n, err := f.Write(expected); err != nil {
		return false, fmt.Errorf("error writing %s: %w", dst, err)
	} else if n != len(expected) {
		return false, fmt.Errorf("short write to %s", dst)
	}
	return true, nil
}

func SyncSshdConfigCommand() (*cobra.Command, error) {
	var opts SyncSshdConfigOpts
	cmd := &cobra.Command{
		Use: "sync-sshd-config",
		RunE: func(cmd *cobra.Command, args []string) error {
			if os.Geteuid() != 0 {
				return fmt.Errorf("must be run as root")
			}
			cmd.Printf("HostPomeriumConfigDir: %s\n", opts.HostPomeriumConfigDir)
			cmd.Printf("HostConfigFile: %s\n", opts.HostConfigFile)
			cmd.Printf("UserCaCert: %s\n", opts.UserCaCert)
			cmd.Printf("SshdPidFile: %s\n", opts.SshdPidFile)
			cmd.Println()

			ctx, stop := signal.NotifyContext(cmd.Context(), unix.SIGINT)
			defer stop()

			firstRun := true
			for {
				if err := ensureDirectory(cmd, opts.HostPomeriumConfigDir); err != nil {
					return err
				}
				destFilename := path.Join(opts.HostPomeriumConfigDir, "pomerium_user_ca_key.pub")

				updatedPubkey, err := syncPublicKey(cmd, destFilename, opts.UserCaCert)
				if err != nil {
					return err
				}

				var sshdConfigContentsBuf bytes.Buffer
				err = template.Must(template.New("sshd-config").
					Parse(sshdConfigTemplate)).
					Execute(&sshdConfigContentsBuf, opts)
				if err != nil {
					return fmt.Errorf("error generating sshd config: %w", err)
				}

				updatedConfig, err := syncFile(cmd, opts.HostConfigFile, sshdConfigContentsBuf.Bytes())
				if err != nil {
					return err
				}

				if firstRun || updatedPubkey || updatedConfig {
					data, err := os.ReadFile(opts.SshdPidFile)
					if err != nil {
						return fmt.Errorf("error reading sshd pid file %s: %w", opts.SshdPidFile, err)
					}
					pid, err := strconv.ParseInt(strings.TrimSpace(string(data)), 10, 32)
					if err != nil {
						return fmt.Errorf("error parsing pid from %s: %w", opts.SshdPidFile, err)
					}
					cmd.Printf("signaling sshd (pid %d) to reload its configuration... ", pid)
					if err := unix.Kill(int(pid), unix.SIGHUP); err != nil {
						return fmt.Errorf("error sending SIGHUP to sshd process %d: %w", pid, err)
					}
					cmd.Printf("done\n")
				}

				firstRun = false
				if w, err := fsnotify.NewWatcher(); err == nil {
					cmd.Printf("watching for changes to %s...\n", opts.UserCaCert)
					_ = w.Add(opts.UserCaCert)
					select {
					case <-w.Events:
						w.Close()
						cmd.Printf("watched file changed, reloading...\n")
					case <-ctx.Done():
						w.Close()
						return context.Cause(ctx)
					}
				} else {
					cmd.Println("sleeping")
					<-ctx.Done()
					return context.Cause(ctx)
				}
			}
		},
	}
	cmd.Flags().StringVar(&opts.HostPomeriumConfigDir, "host-pomerium-config-dir", "/var/lib/pomerium/ssh", "directory to store pomerium certs in")
	cmd.Flags().StringVar(&opts.HostConfigFile, "host-config-file", "/etc/ssh/sshd_config.d/50-pomerium.conf", "path to the pomerium sshd config file")
	cmd.Flags().StringVar(&opts.UserCaCert, "user-ca-cert", "/var/run/pomerium/ssh/pomerium_user_ca_key.pub", "path to a secret-mounted user CA key to copy to the host")
	cmd.Flags().StringVar(&opts.SshdPidFile, "sshd-pidfile", "/var/run/sshd.pid", "path to sshd.pid")

	return cmd, nil
}
