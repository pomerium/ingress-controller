//go:build embed_pomerium
// +build embed_pomerium

// Package envoy contains functions for working with an embedded envoy binary.
package envoy

import (
	"context"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"

	envoy_config_bootstrap_v3 "github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3"
	"google.golang.org/protobuf/proto"

	"github.com/pomerium/pomerium/pkg/envoy"
	"github.com/pomerium/pomerium/pkg/envoy/files"
)

const (
	ownerRW = os.FileMode(0o600)
)

func init() {
	files.SetFiles(rawBinary, rawChecksum, rawVersion)
}

// Validate validates the bootstrap envoy config.
func Validate(ctx context.Context, bootstrap *envoy_config_bootstrap_v3.Bootstrap, id string) (*ValidateResult, error) {
	bs, err := proto.Marshal(bootstrap)
	if err != nil {
		return nil, err
	}

	cfgName := filepath.Join(os.TempDir(), id+".pb")
	err = ioutil.WriteFile(cfgName, bs, ownerRW)
	if err != nil {
		return nil, err
	}
	// remove the file when we're done
	defer func() { _ = os.Remove(cfgName) }()

	cmd, err := cmd(ctx,
		"--config-path", cfgName,
		"--mode", "validate",
		"--log-level", "error",
		"--log-format", "%v")
	if err != nil {
		return nil, err
	}

	envoyBS, err := cmd.CombinedOutput()
	// an “OK” message (in which case the exit code is 0)
	// or any errors generated by the configuration file (exit code 1)
	if exitErr, ok := err.(*exec.ExitError); ok && exitErr.ExitCode() == 1 {
		return &ValidateResult{
			Valid:   false,
			Message: string(envoyBS),
		}, nil
	} else if err != nil {
		// all other errors are returned as errors
		return nil, err
	}
	return &ValidateResult{
		Valid:   true,
		Message: "OK",
	}, nil
}

// cmd creates an exec.Cmd using the embedded envoy binary.
func cmd(ctx context.Context, arg ...string) (*exec.Cmd, error) {
	fullEnvoyPath, err := envoy.Extract()
	if err != nil {
		return nil, err
	}

	return exec.CommandContext(ctx, fullEnvoyPath, arg...), nil
}
