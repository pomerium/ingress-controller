// Package envoy contains functions for working with an embedded envoy binary.
package envoy

import (
	"context"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"sync"

	envoy_config_bootstrap_v3 "github.com/envoyproxy/go-control-plane/envoy/config/bootstrap/v3"
	"google.golang.org/protobuf/proto"
)

var (
	setupLock          sync.Mutex
	setupDone          bool
	setupFullEnvoyPath string
	setupErr           error
)

func setup() (fullEnvoyPath string, err error) {
	setupLock.Lock()
	defer setupLock.Unlock()

	// if we've extract at least once, and the file we previously extracted no longer exists, force a new extraction
	if setupFullEnvoyPath != "" {
		if _, err := os.Stat(setupFullEnvoyPath); os.IsNotExist(err) {
			setupDone = false
		}
	}
	if setupDone {
		return setupFullEnvoyPath, setupErr
	}

	dir, err := os.MkdirTemp(os.TempDir(), "pomerium-envoy")
	if err != nil {
		setupErr = fmt.Errorf("envoy: failed making temporary working dir: %w", err)
		return
	}
	setupFullEnvoyPath = filepath.Join(dir, "envoy")

	err = extract(setupFullEnvoyPath)
	if err != nil {
		setupErr = fmt.Errorf("envoy: failed to extract embedded envoy binary: %w", err)
		return
	}

	setupDone = true
	return setupFullEnvoyPath, setupErr
}

// Command creates an exec.Cmd using the embedded envoy binary.
func Command(ctx context.Context, arg ...string) (*exec.Cmd, error) {
	fullEnvoyPath, err := setup()
	if err != nil {
		return nil, err
	}

	return exec.CommandContext(ctx, fullEnvoyPath, arg...), nil
}

// A ValidateResult is the result of validation.
type ValidateResult struct {
	Valid   bool
	Message string
}

// Validate validates the bootstrap envoy config.
func Validate(ctx context.Context, bootstrap *envoy_config_bootstrap_v3.Bootstrap, id string) (*ValidateResult, error) {
	if !enabled {
		return &ValidateResult{
			Valid:   true,
			Message: "OK",
		}, nil
	}

	bs, err := proto.Marshal(bootstrap)
	if err != nil {
		return nil, err
	}

	cfgName := filepath.Join(os.TempDir(), id+".pb")
	err = ioutil.WriteFile(cfgName, bs, ownerRW)
	if err != nil {
		return nil, err
	}
	// remove the file when we're done
	defer func() { _ = os.Remove(cfgName) }()

	cmd, err := Command(ctx,
		"--config-path", cfgName,
		"--mode", "validate",
		"--log-level", "error",
		"--log-format", "%v")
	if err != nil {
		return nil, err
	}

	envoyBS, err := cmd.CombinedOutput()
	// an “OK” message (in which case the exit code is 0)
	// or any errors generated by the configuration file (exit code 1)
	if exitErr, ok := err.(*exec.ExitError); ok && exitErr.ExitCode() == 1 {
		return &ValidateResult{
			Valid:   false,
			Message: string(envoyBS),
		}, nil
	} else if err != nil {
		// all other errors are returned as errors
		return nil, err
	}
	return &ValidateResult{
		Valid:   true,
		Message: "OK",
	}, nil
}
